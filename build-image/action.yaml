name: "Build image"
description: "Docker image build and publish"
inputs:
  path_to_dockerfile:
    description: Path to the dockerfile (default = 'Dockerfile')
    default: "Dockerfile"
  docker_build_dir:
    description: Docker build directory (default = '.')
    default: "."
  image_name:
    description: Repo name of the images.
    required: true
  image_tag:
    description: Tag to apply to images.
    default: snapshot-artifact
  lifecycle_policy_file:
    description: Path to the lifecycle policy JSON file (default = 'policy.json')
    default: "policy.json"
  backend_iam_role:
    description: Name of the Terraform backend assumable IAM Role
    default: "github-actions_terraform-backend"
  github_iam_role:
    description: Name of the IAM Role for adding access to ECR repo, also needs to assume the terraform role
    default: "github-actions_github-actions-runner"
  aws_account_id:
    description: AWS Account ID
  aws_region:
    description: Target AWS Region
    default: "eu-central-1"
  build_arguments:
    description: Build arguments to pass to the build
    default: ""
outputs:
  image_tag:
    description: "Image tag"
    value: ${{ steps.build-publish.outputs.image_tag }}
  full_image:
    description: "Full image"
    value: ${{ steps.build-publish.outputs.full_image }}
runs:
  using: "composite"
  steps:
    - uses: actions/checkout@v4
    - name: Configure AWS Credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        role-to-assume: arn:aws:iam::${{ inputs.aws_account_id }}:role/${{ inputs.github_iam_role }}
        aws-region: ${{ inputs.aws_region }}

    - name: Manage ECR
      uses: quinyx-tjeerd/actions/terraform-automated@main
      env:
        TF_VAR_repository_name: ${{ inputs.image_name }}
        TF_VAR_lifecycle_policy: ${{ inputs.lifecycle_policy_file }}
        TF_VAR_iam_role: arn:aws:iam::${{ inputs.aws_account_id }}:role/${{ inputs.github_iam_role }}
      with:
        backend_iam_role: ${{ inputs.backend_iam_role }}
        aws_account_id: ${{ inputs.aws_account_id }}
        aws_region: ${{ inputs.aws_region }}
        aws_service: ECR
        q_service: ${{ inputs.image_name}}
        working-directory: ${{ github.action_path }}

    # - name: Setup Terraform
    #   uses: hashicorp/setup-terraform@v2
    #   with:
    #     terraform_wrapper: false

    # - name: TF init
    #   shell: bash
    #   run: |
    #     set -eux
    #     terraform init -upgrade -reconfigure \
    #       -backend-config='skip_metadata_api_check=true' \
    #       -backend-config='skip_region_validation=true' \
    #       -backend-config='skip_credentials_validation=true' \
    #       -backend-config='region=${{ inputs.aws_region }}' \
    #       -backend-config='bucket=quinyx-terraform-state-${{ inputs.aws_region }}' \
    #       -backend-config='key=automated/ecr/${{ inputs.image_name }}/terraform.tfstate' \
    #       -backend-config='dynamodb_table=quinyx-terraform-locks-${{ inputs.aws_region }}' \
    #       -backend-config='role_arn=arn:aws:iam::${{ inputs.aws_account_id }}:role/${{ inputs.backend_iam_role }}'
    #   working-directory: ${{ github.action_path }}

    # - name: Create ECR repo [TF apply]
    #   shell: bash
    #   run: |
    #     set -eux
    #     terraform apply \
    #       -var 'repository_name=${{ inputs.image_name }}' \
    #       -var 'lifecycle_policy=${{ inputs.lifecycle_policy_file }}' \
    #       -var 'iam_role=arn:aws:iam::${{ inputs.aws_account_id }}:role/${{ inputs.github_iam_role }}' \
    #       -var 'aws_account_id=${{ inputs.aws_account_id }}' \
    #       -auto-approve
    #   working-directory: ${{ github.action_path }}

    - name: Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v2
      with:
        registries: ${{ inputs.aws_account_id }}
        mask-password: "true" # see: https://github.com/aws-actions/amazon-ecr-login#docker-credentials

    - name: Build, tag, and push image to Amazon ECR
      id: build-publish
      shell: bash
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        ECR_REPOSITORY: ${{ inputs.image_name }}
        IMAGE_TAG: ${{ inputs.image_tag }}
      run: |
        BUILDARGS=""
        if [ "${{ inputs.path_to_dockerfile }}" != "Dockerfile" ]; then
          BUILDARGS="-f '${{ inputs.docker_build_dir }}/${{ inputs.path_to_dockerfile }}'"
        fi
        for arg in ${{ inputs.build_arguments }}; do
            BUILDARGS="$BUILDARGS --build-arg $arg"
        done
        echo "Build Args: $BUILDARGS"
        docker build "${{ inputs.docker_build_dir }}" $BUILDARGS -t "$ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG"
        docker push "$ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG"
        echo "IMAGE $IMAGE_TAG is pushed to $ECR_REGISTRY/$ECR_REPOSITORY"
        echo "image_tag=$IMAGE_TAG" 
        echo "full_image=$ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG"
